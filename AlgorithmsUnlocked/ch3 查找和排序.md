# 排序算法和查找算法

这里我们介绍:二分查找 和 四种排序算法

* 二分查找
  前提是排序好的序列,查找的话,由于是每次减半的策略(每次判断基准q = (p + r) / 2),所以时间复杂度是O(lgn)

* 选择排序
    每次选择最小的元素放在前面(找到最小后,再交换),直到剩最后一个元素.特点是,交换次数少,适合移动元素比较耗时的场景,比如
磁盘访问很慢或者占用空间很大.时间复杂度是O(n^2)

* 插入排序
  选择第一本书后的书作为待检测序列,前面的书如果比这本书大,就要后移,直到放到合适的位置.适合基本有序的序列,否则就需要很多的整理操作.
时间复杂度是:O(n^2),如果基本有序就选它,否则它可能比选择排序还有性能差,因为可能会有很多元素移动.

* 归并排序
    选择索引中间的作为基准q,归并(p..q)和(q+1..r),然后进行merge.时间复杂度为:O(N * logN).不是原址排序,属于不稳定排序算法.如果对于空间要求比较严格不要用它,因为它需要额外开辟很多空间用于存放待merge序列.

* 快速排序
  是原址排序,不稳定,时间复杂度O(N * logN)，实际实践中很常用.思路是:选取基准q,然后小的放基准左边,大的放右边,然后对左边进行快排,对右边进行快排,性能和基准选择有关,可以让基准随机产生,和最右侧元素r交换,来提升快排的效率.

## 分治算法的思想
1. 把一个问题分解成多个相似的子问题,
2. 递归的解决子问题
3. 把子问题的解合并成原问题的解


## 二分查找
```c
// 二分查找声明
int binary_search(int *a, int len, int x)

/* 输入:
 * a :已经排序好的数组
 * len:数组长度
 * x:查找数据
 *
 * 输出:找到了输出索引index,否则输出NOT_FIND
*/
1.令 p = 0,  r = len - 1
2.只要p <= r成立:
    A.让q = (p + r) / 2
    B. 若a[q] == x,返回q
    C. 若a[q] > x, r赋值成q - 1
    D. 若q[q] < x, p赋值成q + 1
3.返回NOT_FIND
```

## 选择排序

```c
void selection_sort(int *a, int len)
// 输入:略(数组 & 数组长度)
// 输出:排序好的数组
1. 令i从1..n-2取值
    A.smallest赋值成i
    B.令j从i..(n-1)取值
        i.若a[j] < a[smallest], smallest赋值成j
    C.交换a[smallest]和a[i]
```

## 插入排序
```c
void insert_sort(int *a, int len)
// 输入:略(数组 & 数组长度)
// 输出:排序好的数组

1. 令i从1..(n-1)依次取值
    A. key赋值为a[i], j赋值成i-1
    // 这里尤其注意需要(j>=0 && a[j]>key)同时成立,否则影响插入的位置
    B. 当j>=0同时a[j]>key时:
        i. a[j + 1] = a[j];
        ii. j--
    C.a[j + 1] = a[j]
```

## 归并排序
相似问题:两个排序好的数组归并成一个排序好的数组
由于基准上,两个单元素数组就是排序好的数组,所以可以递归解决问题
```c
void merge_sort(int *a, int p, int r)
/*
 * 输入: a:数组
 *       p:起始索引
 *       r:末尾索引
 *
 * 输出: 排序好的数组
*/
1. 如果p >= r 返回.
2. 否则执行如下操作:
    A. q = (p + r) / 2;
    B. merge_sort(a, p, q)
    C. merge_sort(a, q + 1, p)
    D. merge(a, p, q, r)


void merge (a, p, q, r)
/*输入: a:数组,索引有如下特征:
        p..q:  序列已经是有序的数组
        q+1..r:序列已经是有序数组

 输出:a是有序数组
*/

1. 取n1 = q - p + 1, n2 =  r - q
2. 新数组B [0..n1],长度为n1+1, 新数组C[0..n2], 长度是n2+1
3. 将数组A的元素依次拷贝的数组B和数组C
4. 数组C和数组D的末尾赋值为∞
5. i 和 j分别取0
6. k从p到r取值
    A.如果B[i] <= C[j], 那么就把B[i]拷贝到A[k],并且i++
    C.如果B[i] > C[j], 那么就把C[j]拷贝到A[k],并且j++
```

## 快速排序
```c
void quick_sort(int *a, int p , int r)
// 输入:同上
// 输出:同上

1. 如果p >= r, return
2. q = position(a, p, r)
3. quick_sort(a, p, q - 1)
4. quick_sort(a, q + 1, r)

int position(a, p, r)
// 输入:同上
// 输出:选取基准值,然后小于基准值的放左边,大于基准值的放右边,返回基准值索引q

1. 先做随机索引选取key和a[r - 1]交换,基准的选择影响快排效率
2. 令q取p
3. 令u从p..(r-2)取值
    A. 如果a[u] <= a[r - 1], 交换a[q]和a[u], q++
4. 交换a[q]和a[r - 1],返回q
```
