# 排序算法的下界以及如何超越下界

1. 基于比较的排序的最优速度的时间复杂度,也就是下界是O(N * logN),无法超越下界.

如何超越这个下界呢?不基于比较去排序!!
那么久引出了算法**计数排序**,和基于多次计数排序的算法**基数排序**

## 计数排序

基数排序的原理如下:
1. 通过算法1创建出equal数组,它的索引就是原来数组的值,它的数组值是原来数组的个数
2. 通过算法2创建出less数组,索引的意义不变,值的意义是比这一位索引小的数目是多少,就是前面的元素的累加
3. 通过less数组每一项+1,就得出了每个值它的最终数组的索引,成为next数组
4. 遍历原来的数组,通过next数组找到索引,根据索引放到目的数组中,然后next数组的对应值+1
计数排序是稳定的.

伪代码示例:
```c
/**
 * 1. equal函数获得equal数组
 *void equal(int *a, int n, int m, int *equal)
 *
 * 输入: a :待排序数组
 *       n: 数组的长度
 *       m: 数组元素的最大范围是(0-m-1)
 *      equal:目标数组,返回值,长度为n
 *       -->  这里插入一个知识点,即使不用equip做参数,而是用返回值,实际上底层也会在这里加一个这样的参数进来,因为%rax是存返回值的,它只有8个字节而已,所以底层是不会真的返回了一个数组/结构体的
 *
 * 输出:用返回值输出,equal数组具有index是原数组的值,值是原数组是index的个数
 *
 * 伪代码
 *  1. equip数组清0
 *  2. i从0...(n-1)取值:
 *      A.将index赋值成a[i]
 *      B.将equip[index]自增1
 *
 *
 * 2. less函数获得less数组
 * void  less(int *equal, int m, int *less)
 *
 * 输入 : equal : equal函数返回的equal数组
 *        m     : 范围,值的范围是(0-m-1)
 *        less  : 目标数组
 *
 * 输出:less数组,每个元素的值代表小于索引的个数,也就是前项和
 *
 *  1. less[0]赋值0
 *  2. j从1到m-1
 *      A.less[j]赋值为less[j - 1] + equal[j - 1]
 *
 *
 *  3. 计数排序的排序操作
 * void rearrange(int *a, int *less, int n, int m)
 *
 * 输入: a:原始待排序数组
 *       less:less数组
 *       n:a数组长度
 *       m:less数组长度, a的元素范围是0..m-1
 *
 * 输出:a,排序好的数组
 *
 * 1.创建数组B清0, 数组next
 * 2. j从0..m-1
 *      A.next[j] = less[j] + 1
 * 3.令i从0到n-1取值:
 *      A.key赋值成a[i]
 *      B.index赋值为next[key]
 *      C.B[index]赋值成a[i]
 *      D.next[key]++
 *
*/



```

## 计数排序
### 计数排序的思想
如果要排序的目标的每个元素的长度相同,此时可以从右向左根据每个位的值进行计数排序,然后往左一位再进行计数排序,\
直到最高位也计数排序就得到最终的排序好的数组,并且是稳定的.

可能你会有疑问,为什么要从右往左扫描,而不从左往右,因为最终排在前面的更大方面取决于左边的位,如果先左后右,最后会根据右边的排最终的结果
,会是错误的答案,所以先右边排序,最后左边排序.
最终就会是正确的稳定的结果.

即:基数排序 就是从右到左对每一位执行计数排序